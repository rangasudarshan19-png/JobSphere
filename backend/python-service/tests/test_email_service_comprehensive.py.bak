"""
Comprehensive unit tests for email service
"""
import pytest
from unittest.mock import Mock, patch, MagicMock
from app.services.email_service import EmailService
from app.config.settings import settings


@pytest.fixture
def email_service():
    """Create email service instance for testing."""
    return EmailService()


@pytest.fixture
def mock_smtp():
    """Mock SMTP server connection."""
    with patch('smtplib.SMTP') as mock:
        smtp_instance = Mock()
        mock.return_value.__enter__.return_value = smtp_instance
        yield smtp_instance


class TestEmailService:
    """Test suite for EmailService class."""
    
    def test_email_service_initialization(self, email_service):
        """Test email service can be initialized."""
        assert email_service is not None
        assert hasattr(email_service, 'send_email')
    
    @pytest.mark.email
    def test_send_welcome_email_success(self, email_service, mock_smtp):
        """Test sending welcome email succeeds."""
        # Arrange
        test_email = "newuser@example.com"
        test_name = "Test User"
        
        # Act
        with patch('app.services.email_service.EmailService._get_smtp_connection', return_value=mock_smtp):
            result = email_service.send_welcome_email(test_email, test_name)
        
        # Assert
        assert result is True
        mock_smtp.sendmail.assert_called_once()
    
    @pytest.mark.email
    def test_send_welcome_email_invalid_email(self, email_service):
        """Test sending welcome email with invalid email fails gracefully."""
        # Arrange
        invalid_email = "not-an-email"
        
        # Act & Assert
        with pytest.raises(ValueError):
            email_service.send_welcome_email(invalid_email, "Test User")
    
    @pytest.mark.email
    def test_send_otp_email_success(self, email_service, mock_smtp):
        """Test sending OTP email succeeds."""
        # Arrange
        test_email = "user@example.com"
        test_otp = "123456"
        
        # Act
        with patch('app.services.email_service.EmailService._get_smtp_connection', return_value=mock_smtp):
            result = email_service.send_otp_email(test_email, test_otp)
        
        # Assert
        assert result is True
        mock_smtp.sendmail.assert_called_once()
        
        # Verify OTP is in email content
        call_args = mock_smtp.sendmail.call_args
        email_content = call_args[0][2] if len(call_args[0]) > 2 else ""
        assert test_otp in email_content
    
    @pytest.mark.email
    def test_send_otp_email_validates_otp_format(self, email_service):
        """Test OTP email validates OTP format."""
        # Arrange
        test_email = "user@example.com"
        invalid_otp = "abc"  # Should be 6 digits
        
        # Act & Assert
        with pytest.raises(ValueError, match="OTP must be 6 digits"):
            email_service.send_otp_email(test_email, invalid_otp)
    
    @pytest.mark.email
    def test_send_password_reset_email_success(self, email_service, mock_smtp):
        """Test sending password reset email succeeds."""
        # Arrange
        test_email = "user@example.com"
        reset_token = "test-reset-token-12345"
        
        # Act
        with patch('app.services.email_service.EmailService._get_smtp_connection', return_value=mock_smtp):
            result = email_service.send_password_reset_email(test_email, reset_token)
        
        # Assert
        assert result is True
        mock_smtp.sendmail.assert_called_once()
        
        # Verify token is in email
        call_args = mock_smtp.sendmail.call_args
        email_content = call_args[0][2] if len(call_args[0]) > 2 else ""
        assert reset_token in email_content
    
    @pytest.mark.email
    def test_send_account_suspended_email_includes_support_email(self, email_service, mock_smtp):
        """Test account suspended email includes support contact."""
        # Arrange
        test_email = "user@example.com"
        reason = "Terms violation"
        
        # Act
        with patch('app.services.email_service.EmailService._get_smtp_connection', return_value=mock_smtp):
            result = email_service.send_account_suspended_email(test_email, reason)
        
        # Assert
        assert result is True
        call_args = mock_smtp.sendmail.call_args
        email_content = call_args[0][2] if len(call_args[0]) > 2 else ""
        
        # Verify support email is in content
        assert settings.SUPPORT_EMAIL in email_content
        assert reason in email_content
    
    @pytest.mark.email
    def test_email_template_formatting(self, email_service):
        """Test email template string formatting works correctly."""
        # Arrange
        template = "Hello {name}, your OTP is {otp}. Contact {support_email}."
        
        # Act
        formatted = template.format(
            name="John",
            otp="123456",
            support_email=settings.SUPPORT_EMAIL
        )
        
        # Assert
        assert "John" in formatted
        assert "123456" in formatted
        assert settings.SUPPORT_EMAIL in formatted
        assert "{" not in formatted  # No unformatted placeholders
    
    @pytest.mark.email
    @pytest.mark.slow
    def test_smtp_connection_failure_handling(self, email_service):
        """Test email service handles SMTP connection failures gracefully."""
        # Arrange
        test_email = "user@example.com"
        
        # Act & Assert
        with patch('smtplib.SMTP', side_effect=ConnectionError("SMTP server unavailable")):
            with pytest.raises(Exception):
                email_service.send_welcome_email(test_email, "Test User")
    
    @pytest.mark.email
    def test_email_rate_limiting(self, email_service, mock_smtp):
        """Test email service respects rate limiting."""
        # This is a placeholder - implement actual rate limiting if needed
        # For now, just verify multiple emails can be sent
        
        # Arrange
        emails = [f"user{i}@example.com" for i in range(5)]
        
        # Act
        with patch('app.services.email_service.EmailService._get_smtp_connection', return_value=mock_smtp):
            results = [email_service.send_welcome_email(email, "User") for email in emails]
        
        # Assert
        assert all(results)
        assert mock_smtp.sendmail.call_count == 5


@pytest.mark.email
class TestEmailValidation:
    """Test email validation functions."""
    
    def test_valid_email_formats(self):
        """Test various valid email formats are accepted."""
        from app.utils.sanitizer import InputSanitizer
        
        valid_emails = [
            "user@example.com",
            "user.name@example.com",
            "user+tag@example.co.uk",
            "user123@test-domain.com"
        ]
        
        for email in valid_emails:
            try:
                result = InputSanitizer.sanitize_email(email)
                assert result == email.lower()
            except ValueError:
                pytest.fail(f"Valid email {email} was rejected")
    
    def test_invalid_email_formats(self):
        """Test invalid email formats are rejected."""
        from app.utils.sanitizer import InputSanitizer
        
        invalid_emails = [
            "notanemail",
            "@example.com",
            "user@",
            "user@.com",
            "user space@example.com",
            "<script>alert('xss')</script>@example.com"
        ]
        
        for email in invalid_emails:
            with pytest.raises(ValueError):
                InputSanitizer.sanitize_email(email)
    
    def test_email_normalization(self):
        """Test email addresses are properly normalized."""
        from app.utils.sanitizer import InputSanitizer
        
        # Arrange
        test_cases = [
            ("  User@Example.COM  ", "user@example.com"),
            ("USER@EXAMPLE.COM", "user@example.com"),
            ("user@example.com", "user@example.com")
        ]
        
        # Act & Assert
        for input_email, expected in test_cases:
            result = InputSanitizer.sanitize_email(input_email)
            assert result == expected
